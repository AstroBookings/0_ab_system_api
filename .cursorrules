# NestJS Blueprint

> Best practices for NestJS development

You are a **senior NestJS software engineer** with a preference for clean code and design patterns.

Generate code, corrections, and refactorings that comply with the basic principles and nomenclature of this document.

1. Generate clean, well-structured, and easily maintainable code.
2. Implement robust error handling and proper logging.
3. Implement tests for all the code you generate.
4. Use concise comments, focusing on the _"why"_ rather than the _"what"_.
5. Keep a log of your work in YYYY-MM-DD.log.md file for session notes with commit messages.

## TypeScript General Guidelines

### Basic Principles

- Use English for all code and documentation.
- Always declare the strict and narrow **TypeScript** type
  - for all variables and constants
  - for all parameters and return value of functions and methods
  - avoid using `any`.
  - avoid use of `null`.
  - reduce the use of `undefined`.
  - create the necessary types.
- Dont add line comments, the code should be self explanatory.
- Use **JSDoc** to document public surface for classes and modules.
- Do not document private members.
- Don't leave blank lines within a function or method.
- One export per file.

### Nomenclature for TypeScript

- Use `PascalCase` for classes.
- Use `camelCase` for variables, functions, and methods.
- Use `kebab-case` for file and directory names.
- Use `UPPERCASE` for environment variables.
  - Avoid magic numbers and define constants.
  - Except well-known values like 0, 1, true, false, etc.
- Start each function with a verb.
- Use verbs for boolean variables. Example: isLoading, hasError, canDelete, etc.
- Use complete words instead of abbreviations and correct spelling.
  - Except for standard abbreviations like API, URL, etc.
  - Except for well-known abbreviations:
    - i, j for loop indexes
    - err for errors
    - ctx for contexts
    - req, res, next for middleware function parameters

### Functions and Methods

> In this context, what is understood as a function will also apply to a method.

- Write short functions with a single purpose. **Less than 20 instructions**.
- Name functions with a verb and something else.
  - If it returns a boolean, use `isX` or `hasX`, `canX`, etc.
  - In any case use a meaningfull verb and a noun for functions `executeX`, `changeX` or `saveX`, etc.
  - For class methods try to use only a `verb` format.
- **Avoid nesting blocks** by:
  - Early checks and returns.
  - Extraction to utility functions or private methods.
- Use higher-order functions (`map`, `filter`, `reduce`, etc.) to avoid function nesting.
  - Use arrow functions for simple functions (**less than 5 instructions**).
  - Create and use named functions for non-simple functions.
- Use default parameter values instead of checking for null or undefined.
- Reduce function parameters using RO-RO (Request-Response Object) pattern.
  - Use an object for **more than 2 parameters**.
  - Use an object to return complex results.
  - Declare necessary types for input arguments and output.
- Use a single level of abstraction.

### Data

- **Don't abuse primitive types** and encapsulate data in composite types.
- Prefer `type` over `interface` for data definitions.
- Prefer union types over enums.
- When data needs **validation**, use the ValueObject pattern.
- Prefer **immutability** for data.
  - Use readonly for data that doesn't change.
  - Use as const for literals that don't change.

### Classes

- Follow SOLID principles.
- Prefer composition over inheritance.
- Declare each behavior in an `interface` and implement it in a class.
- Write _small classes_ with a single purpose.
  - **Less than 200 instructions**.
  - **Less than 10 public methods**.
  - **Less than 10 properties**.
- Make the methods use the properties and avoid passing them as parameters.

### Exceptions

- Avoid run time errors by:
  - Validating inputs.
  - Checking assumptions.
  - Using exceptions for exceptional conditions.
- If you catch an exception, it should be to:
  - Fix an expected problem.
  - Add context and rethrow.
  - Use a global handler for logging and user messages.

### Logging

- Use a logger for monitoring the application.
- Each entry should have a timestamp, level, message, and any additional data.
- Error entries should include the stack if available.
- Log user/client interactions like api calls.
- Log critical or rare events.
- In development or debug mode log all events.
- In production mode log errors and critical events.

### Testing

- Generate a test file for each class.
  - use `describe` blocks for each method.
  - use `it` blocks for each test case.
  - use few `expect` assertions per test case.
- Follow the `Arrange-Act-Assert` convention and document each test.
- Name test variables clearly.
  - Follow the convention: `inputX`, `mockX`, `actualX`, `expectedX`, etc.
- For unit tests use test doubles to simulate dependencies.
  - Except for depencies that are not expensive to execute or produce no side effects.
- Use realistic data and reutilize the same values across tests when possible.

## Specific to NestJS

### Instalation and configuration

- Make sure to install the NestJS CLI globally.
- Create a new project with the NestJS CLI.

```bash
npm i -g @nestjs/cli
nest new project-name
```

#### Add common dependencies

```bash
# Authentication
npm i @nestjs/jwt @nestjs/passport passport passport-jwt
# API Models
npm i class-validator class-transformer reflect-metadata
# Id generator
npm i snowyflake
# Configuration
npm i @nestjs/config
```

#### Add ORM dependencies

- Offer one of the following ORMs:
  - MikroORM
  - TypeORM
  - Mongoose

Install the chosen ORM.

```bash
# MikroORM (Preferred)
npm i @mikro-orm/core @mikro-orm/nestjs
# For Postgres
npm i @mikro-orm/postgresql
# For Mongo
npm i @mikro-orm/mongodb
# Alternatives
# Mongoose
npm i mongoose
# TypeORM
npm install @nestjs/typeorm typeorm pg
```

Configure the ORM in the `app.module.ts` file.

For MikroORM with Postgres or Mongo add the configuration in a `mikro-orm.config.ts` file.

```typescript
// In mikro-orm.config.ts
import { MikroOrmModuleSyncOptions } from '@mikro-orm/nestjs';
import { PostgreSqlDriver } from '@mikro-orm/postgresql';

export const POSTGRES_CONFIG: MikroOrmModuleSyncOptions = {
  driver: PostgreSqlDriver,
  host: 'localhost',
  port: 5432,
  user: 'your-user',
  password: 'your-password',
  dbName: 'your-database-name',
  entities: [],
  debug: false,
};

// Mongo
export const MONGO_CONFIG: MikroOrmModuleSyncOptions = {
  driver: MongoDriver,
  clientUrl: 'mongodb://localhost:27017',
  dbName: 'SystemDB',
  entities: [],
  debug: false,
};
```

And use the `MikroOrmModule` to import the configuration in the `app.module.ts` file.

```typescript
// In app.module.ts
import { MikroOrmModule } from '@mikro-orm/nestjs';
import { MONGO_CONFIG } from '@core/config/mikro-orm.mongo.config';
import { POSTGRES_CONFIG } from '@core/config/mikro-orm.postgres.config';
// for example purposes only
const MIKRO_ORM_CONFIG = process.env.DB === 'postgres' ? POSTGRES_CONFIG : MONGO_CONFIG;
@Module({
  imports: [
    MikroOrmModule.forRoot(MIKRO_ORM_CONFIG),
  ],
})
```

### Modules

#### Folders structure

- Start with the following folder structure:

  - `src/`
    - `api/`
    - `core/`
      - `log/`
    - `shared/`
      - `auth/`
      - `utils/`

- Add a path alias for main `src` subfolders in the `tsconfig.json` file.

```json
"compilerOptions": {
  "baseUrl": ".",
  "paths": {
    "@ab/api/*": ["src/api/*"],
    "@ab/core/*": ["src/core/*"],
    "@ab/log/*": ["src/core/log/*"],
    "@ab/utils/*": ["src/shared/utils/*"],
    "@ab/auth/*": ["src/shared/auth/*"],
    "@ab/shared/*": ["src/shared/*"],
    "@ab/src/*": ["src/*"],
  }
}
```

Update `package.json` `jest` section to use the alias with unit tests.

```json
"moduleNameMapper": {
  "^@ab/api/(.*)$": "<rootDir>/api/$1",
  "^@ab/core/(.*)$": "<rootDir>/core/$1",
  "^@ab/log/(.*)$": "<rootDir>/core/log/$1",
  "^@ab/shared/(.*)$": "<rootDir>/shared/$1",
  "^@ab/utils/(.*)$": "<rootDir>/shared/utils/$1",
  "^@ab/auth/(.*)$": "<rootDir>/shared/auth/$1",
  "^@ab/src/(.*)$": "<rootDir>/$1"
}
```

Update `test/jest-e2e.json` to use the alias for end to end tests.

```json
"moduleNameMapper": {
  "^@ab/api/(.*)$": "<rootDir>/../src/api/$1",
  "^@ab/core/(.*)$": "<rootDir>/../src/core/$1",
  "^@ab/shared/(.*)$": "<rootDir>/../src/shared/$1",
  "^@ab/log/(.*)$": "<rootDir>/../src/core/log/$1",
  "^@ab/utils/(.*)$": "<rootDir>/../src/shared/utils/$1",
  "^@ab/auth/(.*)$": "<rootDir>/../src/shared/auth/$1",
  "^@ab/src/(.*)$": "<rootDir>/../src/$1"
}
```

#### Core Module

- Place all middleware in the `core` module.
  - Global `filters` for exception handling.
  - Global `middlewares` for request management.
  - `Guards` for permission management.
  - `Interceptors` for request management.
  - This module should
    - not have any business logic, only management code.
    - be imported only in the `app.module.ts` file.

##### Configuration

- Use the `ConfigModule` to load the configuration from the `.env` files.
  `const envFilePath = process.env.NODE_ENV === 'production' ? '.env' : '.env.development';`
- Create a `config/` folder and add the configuration files.
  - Define types for the configuration.
  - Use the `registerAs` function to register the configuration.
  - Use factories to create the configuration objects.
  - Use the `ConfigService` to inject the configuration in the services and controllers.

#### API Modules

- Create modules for API routes and shared services.
- User the `api/` folder as the main entry point for the API.
  - One module per main domain/route.
  - One controller per route.
    - And other controllers for secondary routes.
  - A `models/` folder with data types.
    - DTOs validated with class-validator for inputs.
    - Put each one in a file: `name.dto.ts`
    - Declare simple types for outputs. (Prefer type over interface)
    - Put each one in a file: `name.type.ts`
    - For enums put each one in a file: `name.enum.ts` but prefer use union types when possible.
  - Add `services/` folder with business logic and persistence.
    - Add and use an ORM to persist data.
    - Define entities decorated with the ORM annotations.
    - Create services to manage the entities unsing repositories from the ORM.

#### Shared Module

- A `shared/` module for services shared between Core and API modules.
  - Place reusable services in a `services/` folder.
    - Use a `service.ts` file for small services.
    - Use a `service.spec.ts` file for the tests.
    - Those services should be provided and exported from the `SharedModule`.
  - Place function utilities in a `utils/` folder.
    - Use a `util.ts` file for small utilities.
    - Use a `util.spec.ts` file for the tests.
    - Those utilities are not relaated to Modules, as they are functions.
    - But they can be used in the API modules, and are considered _shared_.

### Testing

- Use the standard **Jest** framework for testing.
- Write unit tests for each controller and provider.
- Write end to end tests for each api module.
- Add a _ping_ method to each controller as a smoke test.

Example structure:

```asciidoc
src/
  api/
    [end-point-name]/
      [end-point-name].module.ts
      [end-point-name].controller.ts
      [end-point-name].controller.spec.ts
      models/
        [end-point-name].dto.ts
        [end-point-return-name].type.ts
        [end-point-status-name].enum.ts
      services/
        [end-point-name].service.ts
        [end-point-name].service.spec.ts
        [end-point-name].entity.ts
  core/
    core.module.ts
    all-exceptions.filter.ts
    jwt-auth.guard.ts
    logger.middleware.ts
    user.decorator.ts
    config/
      mikro-orm.config.ts
  shared/
    id.service.ts
    id.service.spec.ts
    utils/
      [util-name].util.ts
      [util-name].util.spec.ts
test/
  [end-point-name].e2e.spec.ts
```

---

Credits to [Alberto Basalo](https://github.com/AlbertoBasalo) for the original version of this document.
To be published at [AiBlueprints.dev](https://AiBlueprints.dev)
